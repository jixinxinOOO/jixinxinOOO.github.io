<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>测试页面</title>
      <link href="/2020_06_06/%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2/"/>
      <url>/2020_06_06/%E6%B5%8B%E8%AF%95%E9%A1%B5%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<p>以下为路透中文新闻为您整理的6月1日-6月5日当周中国金融市场摘要:</p><p>汇市:</p><p>–人民币兑美元<a href="https://cn.reuters.com/investing/currencies/quote?srcCurr=CNY&destCurr=USD" target="_blank" rel="noopener">CNY=CFXS</a>当周升0.83%，结束此前连续四周跌势。上周末美国对香港国安法的回应较为温和，再加上全球经济复苏憧憬及欧央行超预期加大刺激计划力度，接连推升市场风险偏好，欧元大涨至三个月高位，美元指数持续走弱，推动人民币周五一度触及逾三周高点。短期需继续关注中美局势的消息面变化，另外年中分红购汇需求料增多，人民币大概率保持区间震荡。</p><a id="more"></a>公开市场操作:<p>–中国央行公开市场本周以创下三个半月新高的净回笼为6月开局，前三日逆回购连续缺席令月初流动性将 向宽期盼受到一定打击；尤其是央行宣布推出两个直达实体的创新工具后，债市对未来常规政策放松预期降温 ，讨论政策是否转向的说法也渐增，期现货明显承压。不过业内人士表示，上述工具仅是央行在定向支持方面的增项，货币政策总的宽松大方向未改。只是随着 国内疫情防控的常态化，政策力度由特定时期的“超宽松”向此前状态恢复，不意味着政策方向发生了转向。</p><p>债市:</p><p>–中国债市本周期现货携手全线大跌，其中中短券领跌，三年期国开债一周收益率累计上行逾40个基点，10年利率债收益率亦累计上行约15个基点。因央行宣布创设支持小微企业的货币政策新工具，引发宽松货币政策转向预期忧虑重击，叠加央行逆回购续做规模不及预期，资金面一度收敛等因素综合发酵，令债市悲观情绪连续释放，抛压沉重。虽然周五情绪稍稳，但短端品种疲弱态势不改，目前市场关注下周MLF到期央行续做情况，以便进一步确认政策方向。</p><p>票据：</p><p>–中国票据市场转贴利率月初不降反升，因不少机构提早为腾挪半年末信贷规模做准备，加之资金未如预期中明显转宽，导致足年国有和股份制银行承兑（国股）电票成交价格本周上行约15个基点（bp），最新在2.25%附近。交易员称，近日大型银行连续提高报价，也是推动本轮走升的原因之一。就现有供求来看，票据价格转为向下的动力不足，当然下一步还要看央行对马上到期的中期借贷便利（MLF）如何安排，以判断资金面形势。</p><p>股市:</p><p>–中国股市沪综指<a href="https://cn.reuters.com/investing/markets/index?symbol=.SSEC" target="_blank" rel="noopener">.SSEC</a>当周升2.8%，创三个月最大单周涨幅。美国总统特朗普对于中国推进香港国安法的回应相对较为温和，提振沪指周一劲扬逾2%；券商股领涨，因上交所表示将适时推出科创板做市商制度、研究引入单次T+0交易。之后大盘在创出近三个月新高后维持高位震荡，在经济自新冠疫情回升、以及面临与美国关系紧张之际，投资人押注中国政府提供更多援助经济措施。</p><p>周末开始中国5月宏观数据将陆续公布，关注中国经济在后疫情时期是否能真正企稳反弹回归正常轨道。由于香港国安法等引发的外部施压不断，中国股市短期上行空间料仍将受限。（完）</p>]]></content>
      
      
      <categories>
          
          <category> Testing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资讯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android资源整理分享</title>
      <link href="/2020_06_06/Android%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%E5%88%86%E4%BA%AB/"/>
      <url>/2020_06_06/Android%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="平时在开发的过程中，自己整理了一些技术文档，做开发就是这样，用到的技术很多，需要有一个自己的工具箱，在开发的时候可以迅速检索找到自己需要的技术"><a href="#平时在开发的过程中，自己整理了一些技术文档，做开发就是这样，用到的技术很多，需要有一个自己的工具箱，在开发的时候可以迅速检索找到自己需要的技术" class="headerlink" title="平时在开发的过程中，自己整理了一些技术文档，做开发就是这样，用到的技术很多，需要有一个自己的工具箱，在开发的时候可以迅速检索找到自己需要的技术"></a>平时在开发的过程中，自己整理了一些技术文档，做开发就是这样，用到的技术很多，需要有一个自己的工具箱，在开发的时候可以迅速检索找到自己需要的技术</h4><h4 id="1、Android基础开发文档（chm格式）"><a href="#1、Android基础开发文档（chm格式）" class="headerlink" title="1、Android基础开发文档（chm格式）"></a>1、Android基础开发文档（chm格式）</h4><p>该文档15年的时候整理出来的，当时初入android开发，所以就动手准备了一些技术积累</p><p><em>注意：chm文档在windows可以直接打开，但是在mac上，我装了好几个支持chm的软件，发现不好用，页面内容不能滚动，所以最好还是用windows电脑打开</em></p><p><img src="https://note.youdao.com/yws/public/resource/e4a7f7ba6382871eaa692f2a88d665ec/xmlnote/719611E03E1A428C9BD442D4D312A427/55" alt="chm截图"></p><p>下面是帮助文档的基本内容</p><p><img src="https://note.youdao.com/yws/public/resource/e4a7f7ba6382871eaa692f2a88d665ec/xmlnote/16FB0C8318CE4C83AA445142435A4D7A/57" alt="chm"></p><a id="more"></a>该[android技术文档](https://pan.baidu.com/share/init?surl=2L4duEELiGTQEX4V7NR4iA)大小113M，资源放在百度网盘下<p>链接: <a href="https://pan.baidu.com/s/12L4duEELiGTQEX4V7NR4iA" target="_blank" rel="noopener">https://pan.baidu.com/s/12L4duEELiGTQEX4V7NR4iA</a>  密码: vjw7</p><h4 id="2、以前公司开发过程中整理的文档"><a href="#2、以前公司开发过程中整理的文档" class="headerlink" title="2、以前公司开发过程中整理的文档"></a>2、以前公司开发过程中整理的文档</h4><p><em>15年在康泰公司上班的时候也有整理过一份平时在开发中用到的技术文档，也是chm形式的，以前工作时热衷于这种本地方式的技术整理，是因为当时觉得这个chm的形式在搜索方面是相当给力的，jdk的开发文档不就是这种吗，当时找jdk中的api时很方便，就想着自己也做一份这样的整理，供自己查找技术文档方便，现在回过头来看，这个chm的形式，一是通用性不好，在mac上就显示不好，二是，图片不能从粘贴板拿到，需要先保存到本地才能引用，类似于word，现在更倾向于在线共享式的这种，比如印象笔记，博客，github，xmind</em></p><p><img src="https://note.youdao.com/yws/public/resource/e4a7f7ba6382871eaa692f2a88d665ec/xmlnote/5241BE55AF4845D18EC5B36CE9C8B4FB/73" alt=""></p><p>这份文档保存在了有道云笔记上，<a href="https://note.youdao.com/ynoteshare1/index.html?id=94b63b9c48c709650d10eaf03f6991af&type=note" target="_blank" rel="noopener">康泰公司总结.chm</a> ，薅一薅有道云的羊毛，这的下载比百度要快一点</p>]]></content>
      
      
      <categories>
          
          <category> Android资源 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 资源 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac常用软件汇总</title>
      <link href="/2020_06_05/%E7%94%9F%E6%B4%BB/mac%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB/"/>
      <url>/2020_06_05/%E7%94%9F%E6%B4%BB/mac%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="1、Scroll-Reveser"><a href="#1、Scroll-Reveser" class="headerlink" title="1、Scroll Reveser"></a>1、Scroll Reveser</h3><p>软件说明：这个软件可以设置你的普通鼠标的滚轮方向，我们都知道，在mac的自带的设置滚动方向设置成自然之后，鼠标滚动的方向很不习惯，但是取消自然方向之后，滚轮的方向又和之前在windows上不一样了，这个软件的作用就是触控板的方向和鼠标滚轮的方向分开来了</p><p>官网下载地址：<a href="https://pilotmoon.com/scrollreverser/" target="_blank" rel="noopener">https://pilotmoon.com/scrollreverser/</a></p><p><img src="https://note.youdao.com/yws/public/resource/e4a7f7ba6382871eaa692f2a88d665ec/xmlnote/CB826DF69B0B4BB39FC7885DE952E351/52" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android定位</title>
      <link href="/2018_01_23/Android/Android%E5%AE%9A%E4%BD%8D/"/>
      <url>/2018_01_23/Android/Android%E5%AE%9A%E4%BD%8D/</url>
      
        <content type="html"><![CDATA[<p>Network:定位快，准确度低，受环境影响小。 GPS：定位慢，准确度高，受环境影响大。 <br><br><a href="http://blog.csdn.net/itleaks/article/details/31511105" target="_blank" rel="noopener">http://blog.csdn.net/itleaks/article/details/31511105</a></p><p><a href="http://blog.csdn.net/luosiye312/article/details/50562309" target="_blank" rel="noopener">三种定位方式</a></p>]]></content>
      
      
      <categories>
          
          <category> 定位 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 标签1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android工作中总结</title>
      <link href="/2018_01_23/Android/Android%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
      <url>/2018_01_23/Android/Android%E5%B7%A5%E4%BD%9C%E4%B8%AD%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="键盘把布局顶起来的解决办法"><a href="#键盘把布局顶起来的解决办法" class="headerlink" title="键盘把布局顶起来的解决办法"></a>键盘把布局顶起来的解决办法</h2><p>方法一：在你的activity中的oncreate中setContentView之前写上这个代码getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);</p><p><a href="http://blog.csdn.net/szming_blog/article/details/45442233" target="_blank" rel="noopener">http://blog.csdn.net/szming_blog/article/details/45442233</a></p><h2 id="Fragment-tab生命周期不调用的解决"><a href="#Fragment-tab生命周期不调用的解决" class="headerlink" title="Fragment+tab生命周期不调用的解决"></a>Fragment+tab生命周期不调用的解决</h2><p><a href="http://blog.csdn.net/csdn_aiyang/article/details/78054709?locationNum=10&fps=1" target="_blank" rel="noopener">http://blog.csdn.net/csdn_aiyang/article/details/78054709?locationNum=10&amp;fps=1</a></p><h2 id="apk混淆"><a href="#apk混淆" class="headerlink" title="apk混淆"></a>apk混淆</h2><p><a href="https://www.jianshu.com/p/d7b7e903cfa7" target="_blank" rel="noopener">https://www.jianshu.com/p/d7b7e903cfa7</a><br/><br><a href="https://www.jianshu.com/p/7436a1a32891" target="_blank" rel="noopener">https://www.jianshu.com/p/7436a1a32891</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Wifi使用</title>
      <link href="/2018_01_23/Android/Wifi%E4%BD%BF%E7%94%A8/"/>
      <url>/2018_01_23/Android/Wifi%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>监听wifi的状态</li></ul><pre>BroadcastReceiver wifiStateBroadcastReceiver=new BroadcastReceiver() {    @Override    public void onReceive(Context context, Intent intent) {        MyLog.i(TAG,"监听到wifi变化");        int wifiState = intent.getIntExtra(WifiManager.EXTRA_WIFI_STATE, -1);        if (wifiState == WifiManager.WIFI_STATE_DISABLING) {            MyLog.i(TAG, "正在关闭");        } else if (wifiState == WifiManager.WIFI_STATE_ENABLING) {            MyLog.i(TAG, "正在打开");        } else if (wifiState == WifiManager.WIFI_STATE_DISABLED) {            MyLog.i(TAG, "已经关闭");            closeLoadingDialog();            ssidTv.setText("");        } else if (wifiState == WifiManager.WIFI_STATE_ENABLED) {            MyLog.i(TAG, "已经打开");            showLoadingDialog();            wifiManager.startScan();        } else {            MyLog.i(TAG, "未知状态");        }    }};</pre><ul><li>获取wifi状态</li></ul><pre>int wifiState = wifiManager.getWifiState();switch (wifiState){    case WifiManager.WIFI_STATE_DISABLED:        MyLog.i(TAG,"WifiManager.WIFI_STATE_DISABLED");        break;    case WifiManager.WIFI_STATE_DISABLING:        MyLog.i(TAG,"WifiManager.WIFI_STATE_DISABLING");        break;    case WifiManager.WIFI_STATE_ENABLED:        MyLog.i(TAG,"WifiManager.WIFI_STATE_ENABLED");        if (intent.getAction().matches(WifiManager.SCAN_RESULTS_AVAILABLE_ACTION)) {            closeLoadingDialog();            processScanResults(wifiManager.getScanResults());        }        break;    case WifiManager.WIFI_STATE_ENABLING:        break;}</pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ListView使用</title>
      <link href="/2018_01_23/Android/ListView%E4%BD%BF%E7%94%A8/"/>
      <url>/2018_01_23/Android/ListView%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="ListView适配器更新"><a href="#ListView适配器更新" class="headerlink" title="ListView适配器更新"></a>ListView适配器更新</h3><pre><code>if(historyListAdapter==null){    historyListAdapter = new DeviceHistoryListAdapter(getActivity(), mSprinklerHistoryList);    historyListView.setAdapter(historyListAdapter);}else{    MyLog.i(TAG,&quot;historyListAdapter!=null&quot;);    historyListView.setAdapter(historyListAdapter);//要重新绑定一下数据，不然条目显示不出来    historyListAdapter.update(historyListView,mSprinklerHistoryList);}public void update( List&lt;SprinklerHistoryBean&gt; sprinklerHistoryList){    mSprinklerHistoryList.clear();    mSprinklerHistoryList.addAll(sprinklerHistoryList);    notifyDataSetChanged();}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git命令基本使用</title>
      <link href="/2018_01_23/%E5%85%B6%E4%BB%96/Git%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2018_01_23/%E5%85%B6%E4%BB%96/Git%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="1、git基本命令"><a href="#1、git基本命令" class="headerlink" title="1、git基本命令"></a>1、git基本命令</h3><ul><li><p>查看本地分支</p><pre><code>$ git branch  </code></pre></li><li><p>查看远程分支</p><pre><code>$ git branch -a    master  * mutilrecall    remotes/origin/master    remotes/origin/mutilrecall  </code></pre></li><li><p>创建本地分支，并切换到分支：</p><pre><code>$ git branch test  kevinliu@TP-A1116-L MINGW64 /e/workspace_ttengine/ttengine (mutilrecall)  $ git checkout test  Switched to branch &apos;test&apos;  </code></pre></li><li><p>关联服务器分支<br/></p><pre><code>$ git checkout -b 20180105aaa origin/20180105aaa</code></pre></li><li><p>删除文件夹 <a id="more"></a></p><pre><code>$ git rm -r -f .idea</code></pre></li><li><p>删掉.gitignore文件</p><pre><code>git rm --cache -r -f .gitignore</code></pre></li><li><p>添加文件</p><pre><code>git add .</code></pre></li><li><p>提交</p><pre><code>git commit -m &quot;去掉.gitignore文件&quot;</code></pre></li><li><p>提交到服务器</p><pre><code>git push origin 20180105branchone</code></pre></li></ul><h3 id="2、git添加忽略文件"><a href="#2、git添加忽略文件" class="headerlink" title="2、git添加忽略文件"></a>2、git添加忽略文件</h3><p><a href="http://blog.csdn.net/wangjiang_qianmo/article/details/51131134" target="_blank" rel="noopener">http://blog.csdn.net/wangjiang_qianmo/article/details/51131134</a></p><h3 id="3、git查看配置的用户名和邮箱"><a href="#3、git查看配置的用户名和邮箱" class="headerlink" title="3、git查看配置的用户名和邮箱"></a>3、git查看配置的用户名和邮箱</h3><pre><code>$ git config user.namejOOO$ git config user.email1131836757@qq.com</code></pre><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li><p>git 提交出现问题You have not concluded your merge (MERGE_HEAD exists).</p><p>  <a href="http://yijiebuyi.com/blog/5b55eb51ad49ce41e2de9c85dd4513ca.html" target="_blank" rel="noopener">http://yijiebuyi.com/blog/5b55eb51ad49ce41e2de9c85dd4513ca.html</a></p><p>  <a href="https://yq.aliyun.com/articles/38130" target="_blank" rel="noopener">https://yq.aliyun.com/articles/38130</a></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>点9图片制作</title>
      <link href="/2017_12_28/Android/%E7%82%B99%E5%9B%BE%E7%89%87%E5%88%B6%E4%BD%9C/"/>
      <url>/2017_12_28/Android/%E7%82%B99%E5%9B%BE%E7%89%87%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2017/12/28/5a44bb4a7fc96.png" alt=""></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>UTC时间</title>
      <link href="/2017_12_28/%E7%94%9F%E6%B4%BB/UTC%E6%97%B6%E9%97%B4/"/>
      <url>/2017_12_28/%E7%94%9F%E6%B4%BB/UTC%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<p>UTC时间</p><p>经常混淆于此，特地研究了一下，记录在此以备忘。<br>整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。UTC与格林尼治平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。在本文中，UTC与GMT含义完全相同。<br>北京时区是东八区，领先UTC八个小时，在电子邮件信头的Date域记为+0800。如果在电子邮件的信头中有这么一行：<br>Date: Fri, 08 Nov 2002 09:42:22 +0800<br>说明信件的发送地的地方时间是二○○二年十一月八号，星期五，早上九点四十二分（二十二秒），这个地方的本地时领先UTC八个小时(+0800， 就是东八区时间)。电子邮件信头的Date域使用二十四小时的时钟，而不使用AM和PM来标记上下午。<br>以这个电子邮件的发送时间为例，如果要把这个时间转化为UTC，可以使用一下公式：<br>UTC + 时区差 ＝ 本地时间<br>时区差东为正，西为负。在此，把东八区时区差记为 +0800，<br>UTC + (＋0800) = 本地（北京）时间 (1)<br>那么，UTC = 本地时间（北京时间)）- 0800 (2)<br>0942 - 0800 = 0142<br>即UTC是当天凌晨一点四十二分二十二秒。如果结果是负数就意味着是UTC前一天，把这个负数加上2400就是UTC在前一天的时间。例如，本地（北京）时间是 0432 （凌晨四点三十二分），那么，UTC就是 0432 - 0800 = -0368，负号意味着是前一天， -0368 + 2400 = 2032，既前一天的晚上八点三十二分。<br>纽约的时区是西五区，比UTC落后五个小时，记为 -0500：<br>UTC ＋ （-0500） = 纽约时间 （3）<br>UTC ＝ 纽约时间 ＋ 0500 （4）<br>把（2）式 － （4）式相比较，<br>UTC = 北京时间 － 0800 ＝ 纽约时间 ＋ 0500 （5）<br>即 北京时间 ＝ 纽约时间 ＋ 1300 （6）<br>即北京时间领先纽约时间十三个小时，由（6）式，<br>纽约时间 ＝ 北京时间 － 1300 （7）<br>在四月下旬，纽约又换用夏令时，又称为日光节约时，比标准纽约时间提前一个小时，实际成为西四区的标准时间，成为 -0400。<br>UTC ＋ （－0400） = 纽约夏令时，套用以上公式，<br>北京时间 ＝ 纽约夏令时 ＋ 1200<br>纽约夏令时 ＝ 北京时间 － 1200<br>在这些转换中，最重要的公式就是<br>UTC ＋ 时区差 ＝ 本地时间<br>时区差东为正，西为负。例如，东八区（北京）是 +0800，西五区（纽约）是-0500，加州是西八区，是-0800，美国中部时区是西六区，-0600，美国山地时区是西七区，-0700，太平洋时区是西八区，-0800，在夏天使用夏时制，成为-0700。德国时区是东一区，+0100，夏天变为+0200。<br>多数电子邮件程序，例如Outlook Express，在显示时间时，计算机程序把时间先转换成为本地时间再显示，例如，邮件的Date域为：<br>Date: Fri, 08 Nov 2002 09:42:22 +0800</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android通知栏</title>
      <link href="/2017_12_28/Android/Android%E9%80%9A%E7%9F%A5%E6%A0%8F/"/>
      <url>/2017_12_28/Android/Android%E9%80%9A%E7%9F%A5%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="1、通知栏基本使用"><a href="#1、通知栏基本使用" class="headerlink" title="1、通知栏基本使用"></a>1、通知栏基本使用</h1><pre>    /**     * 通知栏     * @param context     * @param id     * @param title     * @param text     */    private void showNotification2(Context context, int id, String title, String text, boolean ifOpen) {        MyLog.i(TAG,"showNotification2()");        NotificationCompat.Builder builder = new NotificationCompat.Builder(context);        builder.setSmallIcon(R.drawable.ic_launcher);        builder.setContentTitle(title);        builder.setContentText(text);        builder.setAutoCancel(true);        builder.setOnlyAlertOnce(true);        builder.setTicker("门磁防护通知");        // 需要VIBRATE权限        builder.setDefaults(Notification.DEFAULT_VIBRATE);        builder.setPriority(Notification.PRIORITY_DEFAULT);        builder.setPriority(Notification.PRIORITY_DEFAULT);// 设置该通知优先级        // Creates an explicit intent for an Activity in your app        //自定义打开的界面        Intent resultIntent = new Intent(context, BatteryPoweredContactSensorInfoActivity.class);//        resultIntent.putExtra(DEVICE_ID_KEY, mCurrentBatteryPoweredContactSensor.getId());        resultIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);        PendingIntent contentIntent = PendingIntent.getActivity(context, 0,                resultIntent, PendingIntent.FLAG_UPDATE_CURRENT);        builder.setContentIntent(contentIntent);        NotificationManager notificationManager = (NotificationManager) context                .getSystemService(Context.NOTIFICATION_SERVICE);        notificationManager.notify("1", id, builder.build());    }</pre><a id="more"></a><h1 id="2、自定义通知栏"><a href="#2、自定义通知栏" class="headerlink" title="2、自定义通知栏"></a>2、自定义通知栏</h1><pre>        /**     * 通知栏     * @param context     * @param id     * @param title     * @param text     */    private void showNotification(Context context, int id, String title, String text, boolean ifOpen) {        //自定义通知栏布局        RemoteViews mRemoteViews = new RemoteViews(getPackageName(), R.layout.view_custom_notification);        try {            String currentTime = DateTool.exchangeStringTime2(DateTool.getSpecifiedTime3(Calendar.getInstance()));            mRemoteViews.setTextViewText(R.id.tv_notification_time, currentTime);        } catch (ParseException e) {            e.printStackTrace();        }        mRemoteViews.setTextViewText(R.id.tv_notification_info, text);        mRemoteViews.setTextViewText(R.id.tv_notification_app_name, title);        mRemoteViews.setTextColor(R.id.tv_notification_info, Color.BLACK);        NotificationCompat.Builder builder = new NotificationCompat.Builder(context);        builder.setContent(mRemoteViews)                .setWhen(System.currentTimeMillis())// 通知产生的时间，会在通知信息里显示                .setPriority(Notification.PRIORITY_DEFAULT)// 设置该通知优先级                .setOngoing(true)                .setShowWhen(false)                .setTicker("有新的软件更新")                .setSmallIcon(R.drawable.ic_launcher);//这个属性是自定义通知里面必须要传递的，否则通知不显示        builder.setAutoCancel(true);        builder.setOnlyAlertOnce(true);        // 需要VIBRATE权限        builder.setDefaults(Notification.DEFAULT_VIBRATE);        builder.setPriority(Notification.PRIORITY_DEFAULT);        // Creates an explicit intent for an Activity in your app        //自定义打开的界面        //TODO 这个打开的页面需要确定        Intent resultIntent = new Intent(context, BatteryPoweredContactSensorInfoActivity.class);        resultIntent.putExtra(DEVICE_ID_KEY, mCurrentBatteryPoweredContactSensor.getId());        resultIntent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);        PendingIntent contentIntent = PendingIntent.getActivity(context, 0,                resultIntent, PendingIntent.FLAG_UPDATE_CURRENT);        builder.setContentIntent(contentIntent);        NotificationManager notificationManager = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);        MyLog.i(TAG, "id:" + id);        //TODO 这个显示多个通知条目前还有问题，单个设备的时候，下面代码可以用，多个代码的时候，这个代码可能不太对        if (ifOpen) {            notificationManager.cancelAll();        }        notificationManager.notify(mCurrentBatteryPoweredContactSensor.getId(), id, builder.build());    }</pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android基础</title>
      <link href="/2017_12_28/Android/Android%E5%9F%BA%E7%A1%80/"/>
      <url>/2017_12_28/Android/Android%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h3 id="1、Button的Text英文字体都是大写"><a href="#1、Button的Text英文字体都是大写" class="headerlink" title="1、Button的Text英文字体都是大写"></a>1、Button的Text英文字体都是大写</h3><p>android:textAllCaps=”false”<br><br>全为大写字母这个属性改为false</p><h3 id="2、Button字体的间距和边框间距较大的时候"><a href="#2、Button字体的间距和边框间距较大的时候" class="headerlink" title="2、Button字体的间距和边框间距较大的时候"></a>2、Button字体的间距和边框间距较大的时候</h3><p>android:layout_height=”wrap_content”<br><br>android:layout_height=”@dimen/height_45”<br><br>高度不要设置成wrap_content而是设置成具体的值<a id="more"></a></p><h3 id="3、Android完美检测键盘弹出-收起"><a href="#3、Android完美检测键盘弹出-收起" class="headerlink" title="3、Android完美检测键盘弹出/收起"></a>3、Android完美检测键盘弹出/收起</h3><pre>private void setListenerToRootView() {      final View rootView = getWindow().getDecorView().findViewById(android.R.id.content);      rootView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {          @Override          public void onGlobalLayout() {              LogUtils.d(TAG, "[onGlobalLayout] .. in ..");              boolean mKeyboardUp = isKeyboardShown(rootView);              if (mKeyboardUp) {                  LogUtils.d(TAG, "键盘弹出..");              } else {                  LogUtils.d(TAG, "键盘收起..");              }          }      });  }  private boolean isKeyboardShown(View rootView) {      final int softKeyboardHeight = 100;      Rect r = new Rect();      rootView.getWindowVisibleDisplayFrame(r);      DisplayMetrics dm = rootView.getResources().getDisplayMetrics();      int heightDiff = rootView.getBottom() - r.bottom;      return heightDiff > softKeyboardHeight * dm.density;  }  </pre><h3 id="4、ListView点击条目去掉水波纹效果"><a href="#4、ListView点击条目去掉水波纹效果" class="headerlink" title="4、ListView点击条目去掉水波纹效果"></a>4、ListView点击条目去掉水波纹效果</h3><pre><code>&lt;ListView       android:listSelector=&quot;@android:color/transparent&quot;       android:id=&quot;@+id/schedule_list&quot;       android:layout_below=&quot;@id/diverd_line&quot;       android:layout_width=&quot;match_parent&quot;       android:layout_height=&quot;match_parent&quot;&gt;    </code></pre><p>​    </p><h3 id="5、textView-color设置"><a href="#5、textView-color设置" class="headerlink" title="5、textView color设置"></a>5、textView color设置</h3><pre>mMinuteTip.setTextColor(Color.parseColor("#6495ED"));</pre><h3 id="6、RadioGroup"><a href="#6、RadioGroup" class="headerlink" title="6、RadioGroup"></a>6、RadioGroup</h3><p>它有一个clearCheck方法可以把所有选中的RadioButton都取消选中，不用手动对每一个RadioButton进行取消设置，而且手动取消设置还有错误</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio断点调试</title>
      <link href="/2017_12_28/Android/AndroidStudio%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
      <url>/2017_12_28/Android/AndroidStudio%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>step over F8 执行下一行代码<br><br>Step Out F7 跳出方法或者下一个断点</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>EditText</title>
      <link href="/2017_11_23/Android/EditText/"/>
      <url>/2017_11_23/Android/EditText/</url>
      
        <content type="html"><![CDATA[<h1 id="EditText基本使用"><a href="#EditText基本使用" class="headerlink" title="EditText基本使用"></a>EditText基本使用</h1><ul><li><p>限制字数一行显示</p>  <pre>  android:singleLine="true"  android:maxLength="8"  </pre></li><li><p>点击屏幕其他地方让EditText失去焦点</p>  <pre>    //给整体布局设置一个触摸监听事件，将焦点获取到整体布局身上    ll_sprinkler_schedule_details.setOnTouchListener(new View.OnTouchListener() {          @Override          public boolean onTouch(View view, MotionEvent motionEvent) {              ll_sprinkler_schedule_details.setFocusable(true);              ll_sprinkler_schedule_details.setFocusableInTouchMode(true);              ll_sprinkler_schedule_details.requestFocus();              return false;          }      });  </pre></li><li><p>光标移动到最后</p>  <pre>  et_name.setSelection(et_name.getText().toString().length());  </pre></li><li><p>获取焦点</p>  <pre>  // 如果对edittext组件设置了editText.setFocusable(false);需要重新获取焦点则必须执行：  editText.setFocusable(ture);  editText.setFocusableInTouchMode(true);  editText.requestFocus();   // 注意：这种情况下，当重新点击文本框，是无法打开软键盘，必须点击第二次才能打开。   如果改为：  editText.clearFocus(); 失去焦点  editText.requestFocus();获取焦点  </pre></li><li><p>EditText增加右边图片点击事件</p>  <pre>   et.setOnTouchListener(new OnTouchListener() {  @Override  public boolean onTouch(View v, MotionEvent event) {      // et.getCompoundDrawables()得到一个长度为4的数组，分别表示左右上下四张图片      Drawable drawable = et.getCompoundDrawables()[2];      //如果右边没有图片，不再处理      if (drawable == null)          return false;      //如果不是按下事件，不再处理      if (event.getAction() != MotionEvent.ACTION_UP)          return false;      if (event.getX() > et.getWidth()              - et.getPaddingRight()              - drawable.getIntrinsicWidth()){          et.setText("");      }          return false;  }});  </pre></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java基础</title>
      <link href="/2017_11_23/Java/java%E5%9F%BA%E7%A1%80/"/>
      <url>/2017_11_23/Java/java%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1、复制数组方法-System-arraycopy"><a href="#1、复制数组方法-System-arraycopy" class="headerlink" title="1、复制数组方法 System.arraycopy"></a>1、复制数组方法 System.arraycopy</h2><pre> public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)下面是 System.arrayCopy的源代码声明 : 代码解释:　　Object src : 原数组   int srcPos : 从元数据的起始位置开始　　Object dest : 目标数组　　int destPos : 目标数组的开始起始位置　　int length  : 要copy的数组的长度</pre> <h3 id="2、三目运算符"><a href="#2、三目运算符" class="headerlink" title="2、三目运算符"></a>2、三目运算符</h3><p>三目运算符 (表达式1)?(表达式2):(表达式3)，计算方法是这样的：表达式1是一个逻辑表达式，如果其值为true，则整个表达式的值为表达式2的值，否则为表达式3的值</p><p>例子：int i = (5 &gt; 3) ? (5 + 3) : (5 - 3);结果为i = 8.因为5 &gt; 3为true，所以i = 5 + 3.<br>##</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>生活_软件</title>
      <link href="/2017_11_23/%E7%94%9F%E6%B4%BB/%E7%94%9F%E6%B4%BB-%E8%BD%AF%E4%BB%B6/"/>
      <url>/2017_11_23/%E7%94%9F%E6%B4%BB/%E7%94%9F%E6%B4%BB-%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1、markdown破解版地址"><a href="#1、markdown破解版地址" class="headerlink" title="1、markdown破解版地址"></a>1、markdown破解版地址</h2><p><a href="http://www.3322.cc/soft/16069.html#xzdz" target="_blank" rel="noopener">http://www.3322.cc/soft/16069.html#xzdz</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AndroidStudio环境相关</title>
      <link href="/2017_11_23/Android/AndroidStudio%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3/"/>
      <url>/2017_11_23/Android/AndroidStudio%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="AndroidStudio导入第三方类库源码方法"><a href="#AndroidStudio导入第三方类库源码方法" class="headerlink" title="AndroidStudio导入第三方类库源码方法"></a>AndroidStudio导入第三方类库源码方法</h3><pre><code>http://www.jianshu.com/p/feb3a03d1892</code></pre><h3 id="AndroidStudio3-0编译问题"><a href="#AndroidStudio3-0编译问题" class="headerlink" title="AndroidStudio3.0编译问题"></a>AndroidStudio3.0编译问题</h3><p>问题：All flavors must now belong to a named flavor dimension. Learn more at <a href="https://d.android.com/r/tool" target="_blank" rel="noopener">https://d.android.com/r/tool</a><br/><br>解决方案：<br></p><pre> defaultConfig {    targetSdkVersion：***    minSdkVersion ：***    versionCode：***    versionName ：***    //版本名后面添加一句话，意思就是flavor dimension 它的维度就是该版本号，这样维度就是都是统一的了    flavorDimensions "versionCode"}</pre><p>相关文章：<a href="http://blog.csdn.net/u012893747/article/details/78677354" target="_blank" rel="noopener">http://blog.csdn.net/u012893747/article/details/78677354</a></p><h3 id="androidStudio插件使用"><a href="#androidStudio插件使用" class="headerlink" title="androidStudio插件使用"></a>androidStudio插件使用</h3><p><a href="http://blog.csdn.net/lyj1005353553/article/details/55100563" target="_blank" rel="noopener">http://blog.csdn.net/lyj1005353553/article/details/55100563</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AndroidTrack认识</title>
      <link href="/2017_05_27/Android/AndroidTrack%E8%AE%A4%E8%AF%86/"/>
      <url>/2017_05_27/Android/AndroidTrack%E8%AE%A4%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>终于找到一个开源的可以正确播放我录的wav文件了，真的是太不容易了</p><p><a href="https://github.com/zhangliangming/Android_AudioPlayer/tree/master/libs" target="_blank" rel="noopener">https://github.com/zhangliangming/Android_AudioPlayer/tree/master/libs</a></p><p>还是github帮了我大忙<br>感谢开源拯救了我，开源我的大爱</p><p>嗯，用英文搜索有时候能得到不同的答案</p><a id="more"></a><h2 id="wav如何在播放前获取播放时长"><a href="#wav如何在播放前获取播放时长" class="headerlink" title="wav如何在播放前获取播放时长"></a>wav如何在播放前获取播放时长</h2><p><a href="http://blog.csdn.net/91program/article/details/2539636" target="_blank" rel="noopener">http://blog.csdn.net/91program/article/details/2539636</a></p><p>直接读取wav文件头信息，从文件起始地址偏移28个字节长度为4个字节保存的是每秒钟播放的字节数，从文件起始地址偏移40个字节长度为4个字节保存的是声音数据的总的字节数，相除就是播放时间</p><p>采样率：就是对声音信息1秒钟采样多少次，以记录成数字信息。如CD音频是44.1KHz采样率，它对声音以每秒44100次的频率来记录信息。原则上采样率越高，声音的质量越好</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Java常用工具类</title>
      <link href="/2017_05_26/Java/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2017_05_26/Java/Java%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="byte数组转十六进制字符数组"><a href="#byte数组转十六进制字符数组" class="headerlink" title="byte数组转十六进制字符数组"></a>byte数组转十六进制字符数组</h1><pre><code>/** * byte数组转换成16进制字符数组 *  * @param src * @return */public static String[] bytesToHexStrings(byte[] src) {    if (src == null || src.length &lt;= 0) {        return null;    }    String[] str = new String[src.length];    for (int i = 0; i &lt; src.length; i++) {        int v = src[i] &amp; 0xFF;        String hv = Integer.toHexString(v);        if (hv.length() &lt; 2) {            str[i] = &quot;0&quot;;        }        str[i] = hv;    }    return str;}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo+github搭建个人博客教程</title>
      <link href="/2017_05_23/%E5%85%B6%E4%BB%96/%E4%BD%BF%E7%94%A8Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
      <url>/2017_05_23/%E5%85%B6%E4%BB%96/%E4%BD%BF%E7%94%A8Hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="一、hexo常用命令"><a href="#一、hexo常用命令" class="headerlink" title="一、hexo常用命令"></a>一、hexo常用命令</h3><pre><code>hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）hexo deploy #部署到GitHubhexo help  #查看帮助hexo version  #查看Hexo的版本</code></pre><h4 id="1-缩写："><a href="#1-缩写：" class="headerlink" title="1.缩写："></a>1.缩写：</h4><pre><code>hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy</code></pre><h4 id="2-组合命令"><a href="#2-组合命令" class="headerlink" title="2.组合命令"></a>2.组合命令</h4><pre><code>hexo s -g #生成并本地预览hexo d -g #生成并上传</code></pre><h4 id="3-创建一篇新的博客步骤"><a href="#3-创建一篇新的博客步骤" class="headerlink" title="3.创建一篇新的博客步骤"></a>3.创建一篇新的博客步骤</h4><a id="more"></a><pre><code>1、进入到FirstHexo文件根目录2、右键git bash here（windows下操作）3、使用命令 hexo new 文章名4、hexo generate生成静态页面至public目录5、hexo server 在本地查看是否生成6、hexo d 将文章发布到github上面</code></pre><p>注意：一些非md文件可以把他们放到source文件夹下，这里的所有文件都会原样复制（除了md文件）到public目录的</p><h4 id="4-阅读全文功能"><a href="#4-阅读全文功能" class="headerlink" title="4.阅读全文功能"></a>4.阅读全文功能</h4><p>在编辑文章时，适当位置添加 一下代码 ，这样可以避免在首页列表文章的全部内容都显示出来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><h4 id="5-评论功能"><a href="#5-评论功能" class="headerlink" title="5.评论功能"></a>5.评论功能</h4><p>1、使用第三方来必力可以实现，这个有登录功能，这个配置很简单，网上有教程，我一直没有实现的问题，在于Hexo默认的的Disqus的配置我是打开的，enable:false才对，搞了有一个多小时的时间，找不到原因在哪里，现在静下来心去看这个_config.xml文件突然发现它是打开的，然后关掉之后，立马裕兴出来了</p><p><img src="https://note.youdao.com/yws/public/resource/b3288c1dee028e75dd6355491528ec7f/xmlnote/A4006F2013C4458FB2D5C8CF393B0733/81" alt="Disqus"></p><p>2、使用valine也可以，这个就是不登录也可以评论，个人感觉不是很好，配置也不难</p><h4 id="6-阅读统计"><a href="#6-阅读统计" class="headerlink" title="6.阅读统计"></a>6.阅读统计</h4><p>这个使用不蒜子</p><hr><h3 id="二、其他配置"><a href="#二、其他配置" class="headerlink" title="二、其他配置"></a>二、其他配置</h3><h4 id="1-添加统计功能"><a href="#1-添加统计功能" class="headerlink" title="1.添加统计功能"></a>1.添加统计功能</h4><pre><code>我是在根据这个页面来添加的，采用的是最简单的计算网站访问量http://ibruce.info/2015/04/04/busuanzi/</code></pre><h4 id="2-添加图片"><a href="#2-添加图片" class="headerlink" title="2.添加图片"></a>2.添加图片</h4><p><em>我目前采用的是，将图片有道云笔记上，然后将该笔记共享出去，获取图片的链接，然后再引用到文章里面，后期可能会采取图床加云服务器的方式</em></p><pre><code>http://www.cnblogs.com/jarson-7426/p/5515870.html</code></pre><h4 id="3-站内关键字搜索"><a href="#3-站内关键字搜索" class="headerlink" title="3.站内关键字搜索"></a>3.站内关键字搜索</h4><pre><code>http://www.tuicool.com/articles/ZRZnErq</code></pre><h4 id="4-分类和标签"><a href="#4-分类和标签" class="headerlink" title="4.分类和标签"></a>4.分类和标签</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: 测试页面</span><br><span class="line">date: 2018-06-06 00:13:22</span><br><span class="line">tags: </span><br><span class="line">- 资讯</span><br><span class="line">type: &quot;categories&quot; ##这个“categories”是固定的，不能改名</span><br><span class="line">categories: Testing ##该文章被分类整理在Testing下</span><br><span class="line">comments: true ##是否开启评论</span><br></pre></td></tr></table></figure><hr><h3 id="外链推荐"><a href="#外链推荐" class="headerlink" title="外链推荐"></a>外链推荐</h3><p>第一次使用hexo的推荐教程文章：</p><p><a href="http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p><p><a href="http://sanwen.net/a/bwimzoo.html" target="_blank" rel="noopener">http://sanwen.net/a/bwimzoo.html</a></p><p><a href="http://www.jianshu.com/p/bcdbe7347c8d" target="_blank" rel="noopener">http://www.jianshu.com/p/bcdbe7347c8d</a></p><p>next使用：</p><p><a href="http://blog.csdn.net/zuoziji416/article/details/53204478" target="_blank" rel="noopener">http://blog.csdn.net/zuoziji416/article/details/53204478</a><br><a href="https://segmentfault.com/a/1190000010881874" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010881874</a></p><p>其他推荐：</p><p><a href="http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html" target="_blank" rel="noopener">http://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p><p><a href="http://blog.csdn.net/lijiajun95/article/details/53862528" target="_blank" rel="noopener">http://blog.csdn.net/lijiajun95/article/details/53862528</a></p><p><a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">https://segmentfault.com/a/1190000009544924</a></p><p><a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">Next主题官方使用教程</a></p><p><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo官方使用教程</a></p><p>next常见问题解决</p><p><a href="https://blog.csdn.net/shuiyunxc/article/details/104150894" target="_blank" rel="noopener">https://blog.csdn.net/shuiyunxc/article/details/104150894</a></p><p><a href="https://blog.csdn.net/weixin_43790779/article/details/104854588" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43790779/article/details/104854588</a></p><p>Hexo 添加标签云</p><p><a href="https://www.jianshu.com/p/2bb36378045d" target="_blank" rel="noopener">https://www.jianshu.com/p/2bb36378045d</a></p><p>hexo 下的分类和表签无法显示，怎么解决？</p><p><a href="https://www.zhihu.com/question/29017171" target="_blank" rel="noopener">https://www.zhihu.com/question/29017171</a></p><p><a href="https://www.jianshu.com/p/f138032e7539" target="_blank" rel="noopener">https://www.jianshu.com/p/f138032e7539</a></p><p>hexo博客优化之文章置顶+置顶标签</p><p><a href="https://blog.csdn.net/qwerty200696/article/details/79010629" target="_blank" rel="noopener">https://blog.csdn.net/qwerty200696/article/details/79010629</a></p><p>修改标签#号</p><p><a href="https://www.jianshu.com/p/41bf7ebeafdc" target="_blank" rel="noopener">https://www.jianshu.com/p/41bf7ebeafdc</a></p><p>来比力评论功能教程</p><p><a href="https://www.jianshu.com/p/61abc6c43220" target="_blank" rel="noopener">https://www.jianshu.com/p/61abc6c43220</a></p><p>Hexo使用不蒜子统计功能失效问题解决</p><p><a href="https://www.jianshu.com/p/089762f90e1c" target="_blank" rel="noopener">https://www.jianshu.com/p/089762f90e1c</a></p><p>Hexo添加字数统计、阅读时长</p><p><a href="https://www.cnblogs.com/php-linux/p/8418518.html" target="_blank" rel="noopener">https://www.cnblogs.com/php-linux/p/8418518.html</a></p><p>Seo优化</p><p><a href="https://blog.csdn.net/lansus/article/details/89641760" target="_blank" rel="noopener">https://blog.csdn.net/lansus/article/details/89641760</a></p><p><a href="https://www.jianshu.com/p/3a05351a37dc" target="_blank" rel="noopener">https://www.jianshu.com/p/3a05351a37dc</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android贝塞尔曲线初步使用</title>
      <link href="/2017_05_23/Android/Android%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/"/>
      <url>/2017_05_23/Android/Android%E8%B4%9D%E5%A1%9E%E5%B0%94%E6%9B%B2%E7%BA%BF%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1、什么是贝塞尔曲线"><a href="#1、什么是贝塞尔曲线" class="headerlink" title="1、什么是贝塞尔曲线"></a>1、什么是贝塞尔曲线</h1><p><font color=#1234ff size=3>贝塞尔曲线</font>，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图像软件通过它来精确画出曲线，贝塞尔曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的(ps<br>工具里面的钢笔工具)。主要结构：起始点、终止点（也成锚点）、控制点，通过调整控制点，贝塞尔的形状会发生变化<br><br>有关贝塞尔曲线的知识：<code>http://www.html-js.com/article/1628</code></p><h1 id="2、贝塞尔曲线的分类"><a href="#2、贝塞尔曲线的分类" class="headerlink" title="2、贝塞尔曲线的分类"></a>2、贝塞尔曲线的分类</h1><p>贝塞尔曲线分为：一阶贝塞尔曲线、二阶贝塞尔曲线、三阶贝塞尔曲线、四阶、五阶……</p><a id="more"></a><h1 id="3、贝塞尔曲线简单使用"><a href="#3、贝塞尔曲线简单使用" class="headerlink" title="3、贝塞尔曲线简单使用"></a>3、贝塞尔曲线简单使用</h1><ul><li><p>一阶贝塞尔曲线<br><br>  这个非常简单，就是调用canvas的drawLine方法，传进去起点坐标、终点坐标就可以</p></li><li><p>二阶贝塞尔曲线</p><p>  以下代码是最简单的二阶贝塞尔曲线使用</p><pre>   class BezierView extends View {  public BezierView(Context context) {      super(context);  }  protected void onDraw(Canvas canvas) {      /**       * 点的坐标集合       */      List<Float> points = new ArrayList<Float>();      // 添加第一个点(118.0, 294.0),      points.add((float) 118.0);// X轴      points.add((float) 294.0);// Y轴      // 添加第二个点      points.add((float) 206.0);      points.add((float) 294.0);      // 添加第三个点      points.add((float) 294.0);      points.add((float) 118.0);      // 添加第四个点      points.add((float) 382.0);      points.add((float) 206.0);      points.add((float) 470.0);      points.add((float) 118.0);      Paint mPaint=new Paint();      Path mPath = new Path();      mPaint.setColor(Color.RED); // 画笔颜色      mPaint.setStrokeWidth(5); // 画笔宽度      mPaint.setStyle(Paint.Style.STROKE);      mPath.reset();      // 起点      mPath.moveTo(points.get(0), points.get(1));      // 画路径， 参数依次为控制点坐标x,y,终点坐标x,y      mPath.quadTo(points.get(2), points.get(3),points.get(4), points.get(5));      // 画path      canvas.drawPath(mPath, mPaint);      // 画控制点,其实这个画出来不画出来无伤大雅      canvas.drawPoint(points.get(2), points.get(3), mPaint);      // 画线      canvas.drawLine(points.get(0), points.get(1), points.get(2), points.get(3), mPaint);      canvas.drawLine(points.get(4), points.get(5), points.get(2), points.get(3), mPaint);      invalidate();  }  } </pre> </li></ul><p>效果图如下：<br>    ！<a href="https://ooo.0o0.ooo/2017/05/17/591be4d88d587.png" target="_blank" rel="noopener">哈哈</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
